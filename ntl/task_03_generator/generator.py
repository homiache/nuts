# coding=utf-8


# Write generator merge(…) which accepts as arguments an arbitrary number of iterables, each of which generates sorted
# numbers, not necessarily one after another. merge() must merge the outputs of the iterables, i.e. give a sorted queue
# of all the numbers from the input iterables. merge() must correctly stop if all of the input iterables have stopped.
# Please supply unit tests for your solution.
#
# E.g., the input iterables are three generators giving the following numbers:
#
# Iterable 1: 1, 5, 9
# Iterable 2: 2, 5
# Iterable 3: 1, 6, 10, 11
#
# The sequence generated by merge(…) in this case must be: 1, 1, 2, 5, 5, 6, 9, 10, 11
#
# There exists a standard python solution based on heapq.merge, but we would like that you write your solution
# from scratch without using heapq module.


class Merge(object):
    def __init__(self, *args):
        """
        The function:
          - gets a number of input objects;
          - check that all of them are iterables;
          - create a map of iterables;
          - create a slice from iterables.
        :param args: any number of iterables.
        """
        self.dict_of_iterators = self.__dict_of_iterators(args)

    def __iter__(self):
        pass

    def __next__(self):
        pass

    @staticmethod
    def __dict_of_iterators(*args):
        """
        The function gets iterables and return a dict like {1: iteraror_1, 2: iterator_2, ...}
        :param args: iterables
        :return: dict, dict of iterators.
        """
        # Input shouldn't be empty.
        if len(args) == 0:
            raise Exception("Should be at least one iterable in input.")

        # Is used as a key for the dict.
        i = 0

        # Dict with iterators.
        dict_of_iterators = {}

        for each in args:
            try:
                dict_of_iterators[i] = each.__iter__()
            except TypeError:
                raise Exception("{} is not iterable.".format(each))

        return dict_of_iterators
